# Computing and Code (~15 mins)

## A Brief History
At first, computers were essentially glorified abacuses. Using mechanical parts, people were able to manipulate them to perform large or tedious calculations. However, one major downside of these machines was that they were not suitable for calculations involving many variables, as it would be hard to put together the mechanisms necessary to perform such large calculations. Early mechanical computers were also often unable to perform a variety of calculations, instead being built to solve specific equations.

One solution to these problems was to use *digital* instead of *mechanical* mediums. Instead of using physical moving parts, people started using vacuum tubes, which were components able to show an "on" and "off" state using electricity. By combining vacuum tubes into computers as big as a room, people were able to create computers such as the Mark I and the ENIAC, which could perform fairly complex calculations, and that were also re-programmable via punch cards or punch tape. The first programmers were able to use punch cards or tape in a labour-intensive process to instruct early computers to do things such as calculate shell firing trajectories. Later advances allowed computers to store calculations to run again later. These "stored programs" were the true beginnings of what we now know as software. Programmers often had to write in "machine code", which is close to binary, to make computers actually do things.

> ðŸ“– If you want to read more about this, [The Innovators by Walter Isaacson](https://www.simonandschuster.com/books/The-Innovators/Walter-Isaacson/9781476708706) is an excellent book on the history of computers, from the original mathematicians all the way to iPhones. In fact, it's where most of the above information comes from!

## Code and Languages Today
Today, our computers and code have obviously improved far beyond the ones in the 1900s. We use programming languages to tell our computers what to do, instead of punch tape. Instead of the few programming languages that existed at the time, we now have a wide array of languages, some big and some small. In particular, most programming languages can be placed on a spectrum of low-level to high-level.

**Low-level** languages require the programmer to work closely with memory and chips to make things happen. This is often an intensive process, as many code structures must be manually built or defined. However, it also gives the programmer more control over what the program does and how it does it. As a result, code written in more low-level languages is often faster and takes up less memory. Examples of low-level languages include C, C++, and Rust.

**High-level** languages abstract most of the complexity of low-level languages away. Instead of worrying about how the code interacts with physical components, the programmer can use shorter, more intuitive commands to direct the computer, and the machine fills in the blanks based on pre-written code. While high-level languages are more friendly and convenient, programs written using them are usually slower and take up more memory than programs in low-level languages since more things are done automatically. Examples of high-level languages include Python and JS.

In this book, we'll be working with Python, as it's a very flexible, multi-purpose language that's both powerful and beginner-friendly.

## Onto the Code!
Now that you know a bit about the history of computers and code, let's move on to talking about some code basics.
